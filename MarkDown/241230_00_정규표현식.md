# 정규 표현식(Regular Expression)

## 메타 문자 
정규표현식 작성에 사용되는 문자( .(dot), ^, $, *, +, -, ?, {}, [], \, |, () )


## 사용 방법


### 정규식 패턴 complie 사용

```
pat = re.compile("regual expression")
pat.function("string")
```

``` python
import re
pattern = "[a-z]"
text = "hello??"
pat = re.compile(pattern)
match_rs = pat.match(text)
search_rs = pat.search(text)
findall_rs = pat.findall(text)
finditer_rs = pat.finditer(text)
print(match_rs)
print(search_rs)
print(findall_rs)
print(finditer_rs)

<re.Match object; span=(0, 1), match='h'>
<re.Match object; span=(0, 1), match='h'>
['h', 'e', 'l', 'l', 'o']
<callable_iterator object at 0x0000021B7D6C85E0>

```

### compile 없이 바로 사용

```
re.function("regual expression", "string")
```
``` python 
print(re.match("[a-z]", "hello??"))
print(re.search("[a-z]", "hello??"))
print(re.findall("[a-z]", "hello??"))
print(re.finditer("[a-z]", "hello??"))

<re.Match object; span=(0, 1), match='h'>
<re.Match object; span=(0, 1), match='h'>
['h', 'e', 'l', 'l', 'o']
<callable_iterator object at 0x0000021B7D77E110>
```

※ 위 예제는 `정규식 소문자 a ~ z`를 `hello???` 문자열을 검색한 결과이다.


## 문자열 검색 함수

match, search, findall, finditer 4종류가 있다.

※ 하단의 정규표현식 [abcd]는 a 또는 b 또는 c 또는 d가 일치하는지 

### match : 문자열의 앞에서부터 정규식과 매치되는지 확인

``` python
import re
a = re.match("[abcd]", "abcd")
print(a)
print(a.group())
print(a.start())
print(a.end())
print(a.span())

<re.Match object; span=(0, 1), match='a'>
a
0
1
(0, 1)

```
※ 매칭된 결과는 re.Math object 타입이고 검색된 위치는 span 0~1, 검색된 단어는 a






### search : 문자열 전체에서 정규식과 매치 여부를 확인

``` python
import re
a = re.search("[abcd]", "1234abcd")
print(a)
print(a.group())
print(a.start())
print(a.end())
print(a.span())

<re.Match object; span=(4, 5), match='a'>
a
4
5
(4, 5)

```

### findall : 정규식과 매치되는 모든 문자열을 **리스트 객체**로 리턴

``` python
all = re.findall("[abcd]", "1234abcd")
print(type(all))
print(all)

for i in all:
    print(i)

<class 'list'>
['a', 'b', 'c', 'd']
a
b
c
d

```

### finditer : 정규식과 매치되는 모든 문자열을 **이터레이터 객체**로 리턴


``` python
all = re.finditer("[abcd]", "1234abcd")
print(type(all))
print(all)

for i in all:
    print(i)

<class 'callable_iterator'>
<callable_iterator object at 0x0000021B7D77E140>
<re.Match object; span=(4, 5), match='a'>
<re.Match object; span=(5, 6), match='b'>
<re.Match object; span=(6, 7), match='c'>
<re.Match object; span=(7, 8), match='d'>
```

#### group
``` python
all = re.finditer("[abcd]", "1234abcd")
print(type(all))
print(all)

for i in all:
    print(i.group())

<class 'callable_iterator'>
<callable_iterator object at 0x0000021B7D90EDA0>
a
b
c
d
```


#### span

``` python

all = re.finditer("[abcd]", "1234abcd")
print(type(all))
print(all)

for i in all:
    print(i.span())


<class 'callable_iterator'>
<callable_iterator object at 0x0000021B7D8DA4D0>
(4, 5)
(5, 6)
(6, 7)
(7, 8)

```






## [] 문자

대괄호 안에 문자와 일치 여부 

### abc 중 일치하는 하나의 문자 

``` python
import re

pat = re.compile('[abc]')
print(pat.match('bcd'))
print(pat.search('dab'))
print(pat.findall('cba'))

<re.Match object; span=(0, 1), match='b'>
<re.Match object; span=(1, 2), match='a'>
['c', 'b', 'a']
```

``` python
import re

pat = re.compile('[abc]')
matches = pat.findall('apple banana coconut')
print(matches)

['a', 'b', 'a', 'a', 'a', 'c', 'c']
```

### 소문자 a ~ z 

``` python
import re

pattern = r"[a-z]"
text = "Hello Python!!"

matches = re.findall(pattern, text)
print(matches)

['e', 'l', 'l', 'o', 'y', 't', 'h', 'o', 'n']
```

### 대문자 A ~ Z

``` python
import re

pattern = r"[A-Z]"
text = "Hello Python!!"

matches = re.findall(pattern, text)
print(matches)

['H', 'P']
```

### 소문자 a ~ z 와 대문자 A ~ Z


``` python
import re

pattern = r"[a-zA-Z]"
text = "Hello Python!!"

matches = re.findall(pattern, text)
print(matches)

['H', 'e', 'l', 'l', 'o', 'P', 'y', 't', 'h', 'o', 'n']

```


### 숫자 0 ~ 9
[0-9]
### 숫자 0 ~ 9가 아닌 것
[^0-9]







## 자주 사용하는 문자 클래스 

### \d : digit, 숫자와 매치 

``` python
pat.compile('\d')
print(pat.match('1q2w3e4r'))

<>:1: SyntaxWarning: invalid escape sequence '\d'
<>:1: SyntaxWarning: invalid escape sequence '\d'
C:\Users\kj\AppData\Local\Temp\ipykernel_9052\3580348515.py:1: SyntaxWarning: invalid escape sequence '\d'
  pat.compile('\d')
C:\Users\kj\AppData\Local\Temp\ipykernel_9052\3580348515.py:1: SyntaxWarning: invalid escape sequence '\d'
  pat.compile('\d')
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Cell In[251], line 1
----> 1 pat.compile('\d')
      2 print(pat.match('1q2w3e4r'))

AttributeError: 're.Pattern' object has no attribute 'compile'
```

※ \d 사용시 이스케이프 시퀀스 오류 발생하므로 원시문자열 r'\d' 또는 `\\d`를 사용한다.



### \s : space
``` python
```


### \S : space
``` python
```
### \w : word
``` python
```

### \W : word
``` python
```






``` python
import re

pat = re.compile(r'\d')
print(pat.match('1q2w3e4r'))
print(pat.findall('1q2w3e4r'))

```

``` python
import re

pat = re.compile('\\d')  
print(pat.match('1q2w3e4r'))
print(pat.findall('1q2w3e4r'))

```


## 컴파일 옵션 

### DOTALL, S

줄바꿈 문자(\n) 포함하여 매치

``` python
import re
pattern = re.compile('a.b', re.DOTALL) # re.S
matches = pattern.match('a\nb')
print(matches)

```

### IGNORECASE, I


### MULTILINE, M

### VERVOSE, X






## 이스케이프 코드(escape code)

문자열에서 특별한 기능을 사용하기 위한 제어 문자이며
백슬래시로 시작하며 뒤에 문자가 오는 형식을 갖추고 있다.

### \n 

줄바꿈(line feed, LF), 커서를 다음 줄 앞으로 이동

``` python
>>> print("hello\npython")
hello
python
```
### \r 

줄바꿈(Carriage, CR), 커서를 같은 줄 맨 앞으로 이동
``` python
>>> print("hello\rpython")
python
>>> print("hello\rpython\rP")
Python
```

※ 캐리지 리턴은 커서를 현재 줄 맨 앞으로 이동시키며 이 동 후 뒤에 오는 문자들 덮어쓴다.

### \t

``` python
print("hello\tpython")
print("hello   python")
hello	python
hello   python
```

### \\ 

``` python
```

### `\'`

``` python
```

### `\"`

``` python
```


### \a

경고음 

``` python
```

### \b

백스페이스

``` python
```

### \f

Form Feed 새 페이지 시작

``` python
```

### \v
수직 탭(수직 간격) 
``` python
```

### \0

NULL

``` python
```


### \ooo
8진수 
``` python
pritn("\101")
A
```

### \xhh
16진수
``` python
pritn("\x41")
A
```


## 원시 문자열(Raw String)
이스케이프 코드는 백슬래시 + 문자의 형태이기 때문에 아래와 같이 의도하지 않은 결과가 나올 수 있다.

백슬래시를 1개 출력하려면 2개를 작성해야하고, 2개를 출력하려면 4개를 작성해야한다.

``` python
>>> print("youtube\amazon\naver")
youtubemazon
aver
>>> print("youtube\\amazon\\naver")
youtube\amazon\naver
>>> print("youtube\\\\amazon\\\\naver")
youtube\\amazon\\naver
```

문자열 앞에 r을 붙인다.

``` python
>>> print(r"youtube\amazon\naver")
youtube\amazon\naver
```


## 그루핑 


## 그룹핑된 문자열 재참조

정규표현식에서 그룹화를 하면 재사용할 수 있다.


``` python
p = re.compile(r'\b\w+\s\1')
```


## 그룹핑된 문자열 네이밍

``` python

```

